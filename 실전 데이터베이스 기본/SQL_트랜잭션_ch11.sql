-- 트랜젝션

use my_Shop2;

/* 트랜잭션 : 논리적으로 절대 쪼개질 수 없는 하나 이상의 데이터베이스 작업 묶음, 트랜잭션으로 묶인 작업들은 모두 다 성공해야만 그 결과를 실제 데이터베이스에 영구적으로 반영한다.
단 하나의 작업이라도 실패하면, 그 전에 성공했던 모든 작업들은 전부 없던 일로 되돌려 버린다. => Atomic 연산 */

-- 커밋과 롤백
-- 계좌 이체 예제
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (
 id INT PRIMARY KEY,
 owner_name VARCHAR(255) NOT NULL,
 balance INT NOT NULL
);
-- 초기 데이터 입력
INSERT INTO accounts (id, owner_name, balance) VALUES
(1, 'A고객', 40000),
(2, 'B고객', 20000);

-- 성공적인 계좌이체 (COMMIT)
-- 1. 고객의 잔고 확인
select * from accounts;
-- 2. 트랜잭션 시작 후 update 시작하기
start transaction; -- begin이라고도 쓴다. 지금부터 트랜잭션을 시작해라, 이 명령어 이후에 실행되는 모든 쿼리는 하나의 트랜잭션으로 묶여 관리
update accounts set balance = balance - 10000 where id = 1; -- 1번에서 출금    40000 -> 30000
update accounts set balance = balance + 10000 where id = 2; -- 2번으로 입금 / 1번의 출금과 2번의 입금이 하나의 동작으로 여겨져야함!  20000 -> 30000
commit; -- 데이터 베이스에 영구적으로 저장
-- 3. 고객의 잔고 재확인
select * from accounts; -- 성공적인 수정

-- 실수로 인한 작업 취소 ( ROLLBACK )
-- 1. 트랜잭션 시작 후 update 시작하기
start transaction; -- begin이라고도 쓴다. 지금부터 트랜잭션을 시작해라, 이 명령어 이후에 실행되는 모든 쿼리는 하나의 트랜잭션으로 묶여 관리
update accounts set balance = balance - 5000 where id = 1; -- 1번에서 출금    
select * from accounts; -- 30000 -> 25000

-- 오류가 생겨서 더 이상 진행이 되면 안되는 상황 발생!
-- 작업 되돌리기

rollback;
select * from accounts; -- 다시 25000에서 30000으로 바뀐 것을 볼 수 있음!

/* MySQL은 기본적으로 autocommit 모드가 활성화( ON 또는 1 )되어 있다. 이것은 우리가 실행하는 모든 SQL 문 하나하나를 각각의 트랜잭션으로 간주하여, 
성공적으로 실행되는 즉시 자동으로 COMMIT 해버린다는 의미
우리가 위에서 한 것처럼 여러 개의 문장을 하나의 트랜잭션으로 묶고 싶다면, 반드시 START TRANSACTION 명령어로 명시적으로 트랜잭션의 시작을 알려야 함!
START TRANSACTION 을 실행하면, 그 세션에서는 COMMIT 이나 ROLLBACK 을 만날 때까지 autocommit 이 잠시 비활성화된다 */

-- 트랜잭션의 ACID 속성
/*
ACID 

A: Atomic (원자성) - '트랜잭션은 우너자처럼 더이상 쪼갤 수 없는 논리적 단위이며, 전부 성공하거나 전부 실패한다.' = ALL or Nothing
- 모두 성공(commit) : 트랜잭션 전체의 성공
- 모두 실패(ROLLBACK) : 중간에 잘못된 부분이 있거나 오류가 발생했을 경우 작업 들이 모두 취소되어 트랜잭션 전체가 실패로 돌아감!

C: Consistency (일관성) - '트랜잭션이 성공적으로 완료되면, 데이터베이스는 항상 일관된(valid) 상태를 유지해야 한다.'
- 일관성은 트랜잭션의 실행 결과가 데이터베이스에 설정된 모든 규칙(제약 조건 등)을 위반하지 않음을 보장하는 속성을 의미! 
예시> 계좌 이체 로직이라면 초기 A:3,B:4 / 이체 성공 로직이후 A:4,B:3 총합이 7인 것과 각각의 비용이 0 이상인 것, 최종 실행 결과가 제약 규칙을 위반 하지 않는 것을 의미!

I: Isolation (격리성) - '하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 결과에 끼어들어 간섭할 수 없다.'
- 격리성은 여러 트랜잭션이 동시에 실행될 때, 마치 각각의 트랜잭션이 순서대로 하나씩 실행되는 것처럼 느끼게 해주는 특성

상황: A는 50000원 B는 20000원 / A가 B에게 1만원을 이체하는 트랜잭션(T1)을 실행 / UPDATE 로 A의 잔고는 4만원으로 변경 하지만 아직 COMMIT 은 하지 않아 B의 잔고는 2만원인 '중간 상태'임 
바로 그 순간: 옆 창구에서 은행 직원이 전체 고객의 총잔고를 계산하는 트랜잭션(T2)을 실행 
- 격리성이 없다면?: T2는 A의 잔고를 4만원으로, B의 잔고를 2만원으로 읽어서 총액이 6만원이라는 잘못된 결과를 얻음 T1의 아직 완료되지 않은 불안정한 상태(중간단계)를 본 것 (더티 리드(Dirty Read) 발생)
- 격리성이 있다면?: T2는 T1이 아직 COMMIT 되지 않았기 때문에, T1이 임시로 변경한 내용을 보지 못함. T2는 T1이 시작되기 전의 값, 즉 A의 잔고 5만원과 B의 잔고 2만원을 읽어서 정확한 총액 7만원을 계산

- 격리성이 없는 경우 해결 : T1의 트랜잭션 작업을 T2가 볼 수 없도록 격리하기

D: Durability (지속성) - '성공적으로 완료되어 COMMIT 된 트랜잭션의 결과는, 시스템에 장애가 발생하더라도 영구적으로 보존된다.'
- 지속성은 COMMIT 된 데이터는 절대 사라지지 않는다는 약속!!

-- 트랜잭션 격리 수준
데이터 정합성 VS 동시성/성능

-- 동시성 문제
1. 더티 리드 - 트랜잭션이 아직 commit하지 않은 데이터를 다른 트랜젝션이 읽는 것!

2. 반복 불가능 읽기(Non-Repeatable Read) - 한 트랜잭션 내에서 똑같은 select를 두번 했을 때, 첫 조회와 마지막 조회 사이에 다른 트랙잭션이 값을 수정하고 commit해서 두 쿼리의 결과가 다르게 나오는 현상

3. 유령 읽기 - 한 트랜잭션 내에서 특정 범위의 데이터를 두 번 읽었는데 첫 번째 조회에서는 없었던 새로운 행이 두번째 조회에서 나타나는 현상( 다른 트랜잭션이 새로운 행을 insert하고 commit해서 )

-- 격리 수준 4가지
| 격리 수준 (Isolation Level)| Dirty Read | Non-Repeatable Read | Phantom Read  |
| ----------------------- | ----------- | ------------------- | ------------- |
| READ UNCOMMITTED        | 발생         | 발생                  | 발생           |
| READ COMMITTED          | 방지         | 발생                  | 발생           |
| REPEATABLE READ         | 방지         | 방지                  | 발생 (일부 방지*)|
| SERIALIZABLE            | 방지         | 방지                  | 방지           |

- READ UNCOMMITTED : 아무 것도 막아주지 않는, 가장 낮은 수준 -> 데이터 정합성 지켜지지 않아 거의 사용 x
- READ COMMITTED   : 더티 리드를 방지!!, commit 된 데이터만 읽을 수 있음
- REPEATABLE READ  : 더티 리드 방지와 반복 불가능 읽기 방지!!, 한 트랜잭션 안에서 데이터의 일관된 조회 보장, MySQL의 INNO 스토리지 엔진이 사용하는 기본 격리 수준 
                    -> MySQL의 InnoDB 엔진은 MVCC와 갭 락(Gap Lock)이라는 기술을 통해 REPEATABLE READ 수준 에서도 대부분의 팬텀 리드가 발생하는 것을 막아준다 => 노션에 정리해둔 내용 있음 그거 보기!
- SERIALIZABLE     : 가장 엄격한 수준 동시성 문제를 완벽하게 차단하지만, 트랜잭션을 거의 순서대로 실행시켜 동시 처리 성능이 가장 낮음
*/

-- 격리 수준 확인하기
select @@transaction_isolation; -- REPEATABLE-READ 나옴!

-- 격리 수준의 변경 -> 특정 트랜잭션에 적용, 현재 세션에 적용, DB 시스템 전체에 적용

-- 현재 세션에만 변경하기 (일반적)
-- 세션이 머에여?
/* 
-> 세션은 데이터베이스 클라이언트가 데이터베이스 서버에 연결된 순간부터 연결을 종료할 때까지의 논리적인 연결 단위
각 세션은 독립적인 작업 공간을 가지며, 한 세션에서 시작된 트랜잭션은 해당 세션 내에서만 유효 */
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; 

-- 언제 변경을 하지? --트래픽이 매우 많고 반복 불가능 읽기, 유령 읽기 상황이 자주 발생하지 않는 웹 애플리케이션이라면 READ COMMITTED 을 고려할 수 있음!